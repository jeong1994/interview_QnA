const qaData = [
  {
    question: "간단하게 자기소개 해보세요",
    answer: `안녕하세요<br>
저는 비전공자로 시작했지만, 개발이라는 ‘생산의 재미’를 느끼고<br>
개발자가 되기로 결심한 정승환입니다.<br>
국비 교육과정 동안 기능을 구현하는 것뿐 아니라,<br>
팀원들과 함께 문제를 해결하면서 성취감을 느꼈고,<br>
그 경험이 지금까지의 원동력이 되고 있습니다.<br>
아직은 부족한 부분도 많지만, 기회가 주어진다면<br>
맡은 일에 끝까지 책임을 다하고 팀과 함께 성장하는 자세만큼은 자신 있습니다.<br>
오늘 이 자리를 통해 그 기회를 꼭 잡고 돌아가고 싶습니다.`
  },
  {
    question: "이빗에 대해 아는 대로 말해보세요.",
    answer: `제가 이해한 이빗은<br>
IT 인력을 기업에 연결해주는 플랫폼과 신뢰할 수 있는 학습 데이터를 함께 제공하는 회사입니다<br>
단순히 인력을 연결하는 것을 넘어서 AI 기반으로 디지털 생태계를 구축하고<br>
기업과 인재가 함께 성장 할 수 있도록 지원하는 걸 목표로 한다고 알고 있습니다<br>
전문성, 고객만족, 효율성을 핵심가치로 삼고 있다는 점에서<br>
저도 빠르게 배우고 작은 과업부터 책임감 있게 적응하면서<br>
방향에 맞는 인재로 함께 성장하고 싶습니다<br><br>
*핵심 키워드 요약 (암기용)<br>
-IT 인력 연결 + 학습데이터 제공<br>
-AI 기반 디지털 생태계<br>
-기업과 인재의 동반 성장<br>
-핵심가치: 전문성, 고객 만족, 효율성`
  },
  {
    question: "SpringBoot 프로젝트에서 본인이 담당한 구체적인 기술은?",
    answer: `우선 최종 프로젝트인 '맛있는 재활용'에서<br>
음식물 쓰레기 감소를 위한 챗봇 레시피 서비스를 만들었습니다<br>
저는 그 중에서도 OpenAI API를 활용한 챗봇 응답 처리를 담당했고<br>
클라이언트가 보낸 질문을 백엔드에서 API와 통신한 뒤<br>
응답 받은 데이터를 실제 채팅처럼 구조화 해서 출력되도록 가공하는 작업을 했습니다.<br>
다른 작업으로는 OAuth2 방식의 카카오 소셜 로그인과<br>
공공데이터를 메인페이지에 그래프로 시각화 하는 작업을 맡았습니다<br>
전체적으로 RESTful 구조, SpringMVC 패턴, Thymeleaf, Oracle연동 등을 사용했고<br>
협업 중에는 깃허브를 통해 브랜치를 나눠 개발하고 병합까지 직접 경험했습니다`
  },
  {
    question: "교육 이후 시간이 지났는데, 기술을 어떻게 복습하고 있나요?",
    answer: `교육이 끝난 지는 좀 됐지만<br>
개발 공부를 계속 이어가기 위해 사이버대학교 컴퓨터정보통신공학과에 입학했고,<br>
4월에는 SQLD 자격증도 취득했습니다. 정보처리기사는 자격요건이 되지 않아 6월에 있는<br>
기능사 시험을 치를 예정입니다<br>
그리고 최근 1주일 전에는 개인프로젝트 또한 시작하여<br>
퍼블리싱까지 완료한 상태입니다`
  },
  {
    question: "계약직인데도 왜 우리 회사에 지원했나요?",
    answer: `계약직이라는 형태보다, 실제로 개발자로서 일할 수 있는 기회를 얻는 게 더 중요하다고 생각했습니다.<br>
이빗이 추구하는 방향이나 핵심 가치들을 보면서, 저와 잘 맞는다고 느꼈고,<br>
작은 과업부터 책임감 있게 해내면서 실무에 빠르게 적응해보고 싶다는 마음이 컸습니다.<br>
만약 이 자리에서 기회를 얻게 된다면, 단순히 경험만 쌓고 끝나는 게 아니라<br>
계속해서 배우고 기여하면서 오래 함께할 수 있는 사람이 되고 싶습니다.<br><br>
*핵심 키워드 요약 (암기용)<br>
-계약직이어도 기회라 생각<br>
-실무 적응과 성장에 집중하고 싶음<br>
-회사 방향성과 잘 맞는다고 생각했다(전문성, 고객만족, 효율성)`
  },
  {
    question: "API란 무엇인가요?",
    answer: `운영체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스입니다.`
  },
  {
    question: "프레임워크란 무엇인가요?",
    answer: `개발자들이 일정한 틀, 규칙을 가지고 일할 수 있게 제공하는 것을 프레임워크라고 합니다.`
  },
  {
    question: "라이브러리란 무엇인가요?",
    answer: `어떠한 기능을 구현한 코드들의 집합입니다.<br>
class나 메소드로 이루어져 있으며, 필요한 기능을 호출해서 사용할 수 있도록 구성되어 있습니다.`
  },
  {
    question: "패키지란 무엇인가요?",
    answer: `관련 클래스, 인터페이스, 모듈의 집합입니다.<br>
예를 들면 컨트롤러끼리 모아둔 컨트롤러 패키지,<br>
DTO끼리 모아둔 DTO 패키지 등을 만들어 공통된 역할을 하는 파일을 구분합니다.`
  },
  {
    question: "Generic(제네릭)이란 무엇인가요?",
    answer: `클래스나 메서드 작성 시 데이터 타입을 미리 지정하지 않고, 사용할 때 타입을 지정합니다.<br>
코드 재사용성이 높아지고, 컴파일 시 타입 안전성을 확보할 수 있습니다.<br>
자바의 List, Set, Map 등의 자료구조 클래스는<br>
제네릭을 활용하여 다양한 타입의 데이터를 다룰 수 있도록 합니다.`
  },
  {
    question: "1. SpringBoot란 무엇이고, 왜 사용하나요?",
    answer: `기존 스프링 프레임워크를 간편하게 사용할 수 있도록 도와주는 도구입니다.<br>
복잡한 XML 설정 없이도 필요한 의존성을 자동으로 설정해주고<br>
내장 톰캣 서버를 통해 따로 WAS 설치 없이 실행할 수 있어서 빠르게 개발 할 수 있습니다.<br>
<br>
*기존 스프링 - 자바 기반 애플리케이션의 구조를 유연하게 관리 할 수 있도록 도와주는 프레임워크로<br>
제어의 역전과 의존성 주입을 기반으로 객체를 효율적으로 관리하고<br>
코드의 재사용성과 유지보수를 쉽게 해주는 게 장점입니다.<br>
하지만 설정 파일이 복잡하고, XML 기반의 수동 설정이 많아 초기 세팅이 어렵습니다.<br>
-IoC, DI, AOP 기반 프레임워크<br>
-유지보수에 강함<br>
-복잡한 XML 설정이 필요해 학습 난이도 높음<br>
-그래서 SpringBoot로 점점 전환됨<br>
<br>
*핵심 키워드 요약 (암기용)<br>
-스프링을 더 쉽고 빠르게 쓸 수 있게 도와주는 프레임워크<br>
-자동 설정, 내장 서버, 편리한 의존성 관리<br>
-실무에서 자주 사용, 학습과 실습에 효과적`
  },
  {
    question: "2. Spring MVC 패턴의 흐름을 설명해주세요.",
    answer: `Spring MVC는 Model-View-Controller 구조를 기반으로 한 웹 애플리케이션 구조입니다.<br>
클라이언트 요청이 들어오면 Controller가 받고,<br>
비즈니스 로직은 Service와 Model(DB) 에서 처리하고,<br>
결과는 View(HTML, Thymeleaf 등)로 전달됩니다.<br>
이 구조 덕분에 코드가 역할별로 나뉘어 관리가 편하고 유지보수가 좋습니다.`
  },
  {
    question: "3. @Autowired, @RestController, @RequestMapping 어노테이션의 역할은?",
    answer: `우선 @Autowired는 의존성 주입(DI)을 자동으로 처리해주는 어노테이션입니다.<br>
직접 객체를 생성하지 않아도, 필요한 클래스나 Bean을 자동으로 주입받을 수 있어서<br>
코드가 더 간결해지고 유지보수도 쉬워집니다.<br><br>
@RestController는 컨트롤러 클래스임을 표시하면서<br>
반환값을 JSON 형식으로 응답하도록 설정하는 어노테이션입니다.<br>
@Controller와 @ResponseBody를 합쳐놓은 기능이라고 이해했습니다.<br><br>
@RequestMapping은 클라이언트 요청 URL을 어떤 메서드와 매핑할지 지정해주는 어노테이션이고,<br>
GET, POST처럼 메서드 구분도 세부 속성으로 지정할 수 있습니다.<br><br>
저는 이 어노테이션들을 사용해서 REST API를 구성했고,<br>
특히 @Autowired로 서비스나 DAO를 주입받아 기능을 분리하고,<br>
@RestController로 클라이언트에 JSON 응답을 주는 구조를 만들었습니다.<br><br>
*@AutoWired는 스프링이 제공하는 의존성주입(DI) 어노테이션으로<br>
내부적으로 스프링 컨테이너가 구동될 때<br>
해당 필드나 생성자에 맞는 타입의 Bean을 찾아 자동으로 주입합니다<br>
@Autowired가 붙은 필드를 분석하고 적절한 Bean을 찾아 넣어주는 방식입니다<br>
보통은 타입 기준으로 주입되고 동일한 타입의 Bean이 여러개일 경우엔<br>
@Qualifier나 @Primary를 함께 사용해서 어떤 Bean을 넣을지 명시할 수 있습니다<br><br>
*핵심 키워드 요약 (암기용)<br>
-Autowired는 의존성 자동 주입(DI)<br>
-RestController는 JSON 응답을 위한 컨트롤러 지정<br>
-RequestMapping은 요청URL과 메서드를 매핑`
  },
  {
    question: "4. JSP와 Thymeleaf의 차이점은 무엇인가요?",
    answer: `모두 서버 사이드 템플릿 엔진이지만<br>
JSP는 HTML안에 자바 코드를 직접 넣어 동적으로 페이지를 구성합니다<br>
하지만 java코드로 페이지를 동적으로 만들고 응답하는 방식이라 구조가 복잡합니다<br><br>
Thymeleaf는 HTML파일을 그대로 유지하면서 데이터를 바인딩 할 수 있고<br>
th:test, th:if, th:each 같은 속성을 사용해 구조를 깨지 않고 동적 처리를 할 수 있습니다`
  },
  {
    question: "5. Java에서 오버로딩과 오버라이딩의 차이는?",
    answer: `오버로딩: 같은 이름, 파라미터(매개변수) 다름<br>
오버라이딩: 상속받은 부모클래스의 메서드를 재정의`
  },
  {
    question: "6. 자바스크립트에서 비동기 처리 방식엔 어떤 게 있나요?",
    answer: `async/await 을 많이 쓰는데,<br>
비동기 코드를 동기 코드처럼 깔끔하게 작성할 수 있어서 가독성이 좋고 디버깅도 편리합니다.<br>
저는 Ajax를 사용하면서 async/await방식으로 비동기 흐름을 다뤄 봤습니다`
  },
  {
    question: "7. Ajax란 무엇이고, 어떤 상황에서 사용하나요?",
    answer: `페이지 새로고침 없이 서버와 데이터를 주고받을 수 있게 해주는 기술입니다<br>
회원가입 중 이메일 중복확인이나 댓글 작성 후 바로 화면에 반영되도록 처리할 때 사용됩니다<br>
저는 챗봇기능 담당시 채팅을 진행하는 과정이나 메인페이지의<br>
공공데이터API를 시각화하여 불러오는 처리 등에 사용한 기억이 있습니다<br><br>
*핵심 키워드 요약 (암기용)<br>
-페이지 새로고침 없이 서버와 통신<br>
-주로 중복확인, 실시간 검색, 댓글 등에 사용`
  },
  {
    question: "8. Rest API란 무엇이고, RESTful 설계 원칙은 무엇인가요?",
    answer: `REST API는 자원 중심의 설계 방식을 따르는 API입니다.<br>
예를 들어 /users,/comments처럼,<br>
URL 자체가 어떤 데이터를 요청하는지 명확하게 나타내고,<br>
그 자원에 대해 어떤 동작을 할지는 HTTP 메서드로 구분합니다.<br>
예를 들어 GET은 조회, POST는 생성혹은 등록, PUT은 수정, DELETE는 삭제처럼,<br>
URL은 자원만 표현하고, 메서드로 행동을 구분하는 게 REST 방식의 특징입니다<br><br>
저는 실제 프로젝트에서 사용자 정보나 챗봇 응답을 REST API 방식으로 처리했고,<br>
프론트와 데이터를 주고받을 때 이 구조가 명확해서 협업이 쉬웠습니다.<br><br>
RESTful 구조는 백엔드 API를 만들 때, 자원 중심(URL) 으로 표현하고,<br>
그 자원에 어떤 동작을 할지는 HTTP 메서드(GET, POST, PUT, DELETE 등) 로 구분하는 방식입니다.<br>
예를 들어 /recipes는 레시피 목록을 의미하고, GET은 조회, POST는 등록처럼<br>
URL은 의미 있게, 동작은 메서드로 구분하는 게 RESTful한 설계입니다.<br><br>
*핵심 키워드 요약 (암기용)<br>
-URL = 자원<br>
-메서드 = 동작 (GET, POST, PUT, DELETE)<br>
-무상태성 = 서버가 요청 상태를 기억하지 않음<br>
-클라이언트와 서버 명확한 분리라 협업에 유리`
  },
  {
    question: "9. 데이터베이스 연동 시 MyBatis를 사용한 이유와 장점은?",
    answer: `MyBatis는 SQL을 직접 작성하면서도, 객체와 매핑을 자동으로 처리해주는 프레임워크입니다.<br>
SQL을 명확히 컨트롤할 수 있어서, 복잡한 쿼리나 조건이 자주 바뀌는 상황에서 유리하다고 느꼈습니다.<br><br>
또, XML 기반으로 SQL을 분리해서 관리할 수 있어<br>
쿼리 수정이나 디버깅이 편했고,<br>
동적 SQL 처리도 지원해서 실무에서 유연하게 쓰일 수 있다고 생각했습니다.<br><br>
저는 Oracle DB와 연동할 때 MyBatis를 사용해 CRUD를 구현했고,<br>
특히 where 조건이 많은 검색 기능 구현 시에 MyBatis의 장점을 크게 느꼈습니다.`
  },
  {
    question: "10. 본인이 진행한 프로젝트에서 가장 어려웠던 문제와 해결 방법은?",
    answer: `가장 어려웠던 부분은 챗봇 API를 연동하면서,<br>
OpenAI 응답을 웹 페이지에 보기 좋게 출력하는 구조화 문제였습니다.<br>
API 응답은 정상적으로 들어왔지만, 줄바꿈이나 내용이 정리되지 않아서<br>
사용자 입장에선 너무 불편하고 가독성이 떨어지는 형태로 출력됐습니다.<br>
처음엔 텍스트만 잘 받아오면 되는 줄 알았는데,<br>
실제로는 JSON 안에 있는 줄바꿈 문자나 공백, 엔터 처리가 중요한 문제였습니다.<br>
이걸 해결하기 위해 응답값에서 \\n을 <br>로 변환하는 로직을 따로 추가하고,<br>
replace() 메서드를 사용해 줄바꿈 포맷을 HTML에서 자연스럽게 보이도록 가공했습니다.<br>
결과적으로 사용자에게는 실제 채팅처럼 잘 정리된 응답이 출력됐고,<br>
그 과정을 통해 단순한 API 호출이 아니라 프론트 출력까지 고려한 백엔드 처리가 얼마나 중요한지 느꼇습니다.`
  },
  {
    question: "11. 자바에서 예외 처리 방식은 어떻게 되나요?",
    answer: `자바에서는 예외처리를 주로 try-catch-finally, throws, 사용자 정의 예외 클래스를 통해 합니다<br>
트라이 캐치는 예외가 발생할 수 있는 코드를 감싸고 문제가 생겼을 때<br>
프로그램이 중단되지 않고 흐름을 유지할 수 있도록 해줍니다<br>
finally는 예외 발생 여부와 관계없이 항상 실행되는 블록으로 자원 정리같은데 주로 사용합니다<br><br>
throws(던지기)는 메서드 단에서 예외를 호출한 쪽에 넘기는 방식이고<br>
프로젝트에 따라서는 직접 사용자 정의 예외 클래스를 만들어 상황에 맞는<br>
에러 메시지를 전달 하기도 합니다`
  },
  {
    question: "12. 스프링에서 의존성 주입(DI)이란 무엇인가요?",
    answer: `제어의 역전(IoC)은 말그대로 제어의 흐름을 개발자가 아닌 프레임워크가 가져가는 개념입니다<br>
예를들어 객체를 우리가 직접 생성하지 않고, 스프링 컨테이너가 대신 생성하고 관리하는 것입니다<br><br>
그리고 의존성주입은 객체 간의 의존관계를 직접 만들지 않고 외부에서 주입받는 방식입니다<br>
@Autowired, @Constructor, @Bean 등을 통해 자동으로 주입하게 되어있고<br>
저는 프로젝트에서 Service나 Repository 계층에서 주로 사용하면서 객체간 결합도를 줄이고<br>
코드 유지보수가 쉬워진다는 장점을 직접 느꼈습니다<br><br>
IoC는 흐름을 넘기는 개념이고, DI는 객체를 넘기는 방식으로 이해했습니다`
  },
  {
    question: "13. 스프링에서 Bean의 생명주기(Lifecycle)에 대해 설명해주세요.",
    answer: `Bean은 스프링 컨테이너가 관리하는 객체이고, 생명주기는<br>
객체 생성 → 의존성 주입 → 초기화 메서드 실행 후 → 실제 사용 → 컨테이저 종료 시 소멸됩니다`
  },
  {
    question: "14. Spring Boot에서 application.properties와 application.yml의 차이점은?",
    answer: `둘 다 Spring Boot에서 사용하는 설정 파일이고, 기능은 동일합니다.<br>
다만 .properties는 key=value 형식이고, .yml은 들여쓰기 기반이라<br>
복잡한 구조나 계층을 표현할 때 더 가독성이 좋고 정리하기 편합니다.`
  },
  {
    question: "15. JavaScript의 변수 선언 방식(var, let, const)의 차이는?",
    answer: `모두 변수 선언 방식이지만<br>
가장 큰 차이는 유효 범위와 재할당 여부입니다<br>
var는 함수 스코프를 가지며 중복 선언 가능해서<br>
의도치 않은 값 변경이나 호이스팅 이슈가 생길 수 있습니다<br>
let과 const는 블록스코프를 가지며 let은 재할당이 가능하고 const는 불가능합니다<br>
바뀔 일이 없는 값은 const<br>
바뀔 수 있는 값은 let<br>
var는 가급적 사용하지 않는 방향으로 습관을 들이고 있습니다<br><br>
*호이스팅은 변수나 함수 선언이 실제 코드보다 먼저 상단으로 끌어올려지는<br>
자바스크립트의 동작 방식입니다<br>
그래서 코드에서 선언보다 먼저 변수를 사용하는 코드가 가능해지기도 하는데<br>
이 때 중요한 건 초기화 여부입니다<br>
var는 호이스팅이 되면서 undefined로 초기화 되기 때문에 사용은 가능하지만<br>
원치 않는 현상이 발생 할 수 있고<br>
let과 const는 초기화 되기 전까지는 접근 할 수 없기 때문에<br>
선언 전에 사용하면 에러가 발생합니다`
  },
  {
    question: "16. JavaScript에서 'this'는 무엇을 가리키나요?",
    answer: `자바스크립트에서 this는 현재 실행 중인 문맥(context)에 따라 가리키는 대상이 달라집니다.<br>
일반 함수에서는 기본적으로 전역 객체(window) 를 가리키고,<br>
객체의 메서드 안에서는 그 객체 자신을 가리킵니다.<br>
하지만 화살표 함수에서는 this가 자신을 호출한 주체가 아니라, 선언된 위치의 상위 스코프를 따라갑니다.<br>
이벤트 핸들러에서는 일반 함수면 해당 DOM 요소,<br>
화살표 함수면 외부 스코프(this)가 유지됩니다.<br>
사실 이론적으로는 이렇게 이해 했지만<br>
아직까지 숙련된 건 아니지만 필요한 상황이 오면 적용할 수 있도록<br>
준비하겠습니다`
  },
  {
    question: "17. JavaScript에서 이벤트 위임(Event Delegation)이란 무엇인가요?",
    answer: `부모 요소에 이벤트 리스너를 달아 자식 요소의 이벤트를 처리하는 방식입니다<br>
많은 자식요소에 각각 리스너를 다는 대신 부모에서 한번에 처리할 수 있는게 장점입니다<br>
예를 들어 게시판에서 댓글마다 삭제 버튼이 있다고 했을 때<br>
상위 리스트 요소에 한번만 리스너를 달고 event.target을 활용해 버튼을 구분해 처리할 수 있습니다`
  },
  {
    question: "18. CORS란 무엇이고, 왜 발생하나요?",
    answer: `브라우저에서 다른 출처(도메인,포트,프로토콜)의 리소스를 요청할 때 발생하는 보안정책 문제입니다<br>
브라우저는 기본적으로 자기 도메인에서만 요청을 허용하는데<br>
프론트와 백엔드가 도메인이 다를 경우 CORS에러가 발생합니다`
  },
  {
    question: "19. 서블릿(Servlet)과 스프링(Spring)의 차이점은?",
    answer: `서블릿은 Java에서 제공하는 기본 웹 기술로<br>
클라이언트의 요청과 응답을 처리하기 위해 HttpServlet을 직접 상속받아 구현해야합니다<br>
스프링은 이런 서블릿 기반 처리를 추상화해서 더 편리하게 쓸 수 있게 만든 프레임워크입니다<br>
예를들어 서블릿은 요청을 직접 파싱하고 응답을 수동으로 작성해야 하지만<br>
스프링에서는 @Controller, @RequestMapping, @ResponseBody 같은 어노테이션을 통해<br>
간단하게 URL 매핑과 응답 처리를 할 수 있어 생산성이 훨씬 높습니다`
  },
  {
    question: "20. 프로젝트 중 협업이 중요했던 순간은?",
    answer: `최종 프로젝트 기간중 ERD 설계 과정에서 협업이 가장 중요했던 순간으로 기억에 남습니다<br>
JSP 서브프로젝트 당시에는 기능 개발만 신경 쓰느라 ERD를 자세히 맞추지 못했고<br>
그 때문에 테이블 구조가 자주 바뀌면서 프론트와 백엔드 코드가 충돌하는 일이 많았습니다<br>
이 문제를 해결하기 위해 팀원 모두에게 이 불편함을 공유했고 팀원들고 깊게 공감했습니다<br>
이런 과정을 거치며 팀원들과 함께 필요한 컬럼, 데이터 타입, 관계를 정리하면서<br>
기획과 데이터 구조를 맞추는 회의를 충분히 진행했습니다.<br>
그 결과 이후 구현 과정에서는 DB 구조 변경이 거의 없었고,<br>
API 연동도 한 번에 잘 연결되면서 전체 일정도 훨씬 안정적이었습니다.`
  },
  {
    question: "21. 스프링에서 AOP란 무엇인가요? 어떤 상황에서 사용하나요?",
    answer: `AOP는 관점 지향 프로그래밍입니다<br>
핵심 비즈니스 로직과는 별개로 로깅, 트랜잭션 처리, 보안 체크와 같은<br>
공통 기능을 분리해서 처리하는 방식입니다<br>
스프링에서는 AOP를 통해 관점을 정의하고 어드바이스와 포인트컷을 사용해<br>
원하는 지점에 적용할 수 있습니다`
  },
  {
    question: "22. 트랜잭션이란 무엇이며, 언제 사용하는가요?",
    answer: `트랜잭션은 데이터베이스에서 하나의 작업단위를 말합니다<br>
여러 작업이 모두 성공하거나 모두 실패하는 단위 입니다`
  },
  {
    question: "23. 데이터베이스 정규화란 무엇이며, 왜 필요한가요?",
    answer: `정규화는 테이블 구조를 체계적으로 정리해서 데이터 중복을 줄이고 무결성을 높이는 설계 방법입니다<br>
정규화를 통해 중복된 정보를 줄여서 저장공간 낭비를 방지하고<br>
수정 삭제 시 오류를 줄일 수 있습니다`
  },
  {
    question: "24. Java에서 equals()와 ==의 차이는?",
    answer: `==는 객체의 주소(참조값) 를 비교하는 연산자이고,<br>
equals()는 객체 내부의 값(내용) 을 비교하는 메서드입니다.<br>
기본 자료형에선 ==로 값 비교가 가능하지만<br>
객체나 문자열 같은 참조 타입에서는 ==는 주소를<br>
equals()는 오버라이딩 된 내용을 비교해 의도에 맞게 구분해서 사용해야 합니다`
  },
  {
    question: "25. static 키워드의 의미는 무엇인가요?",
    answer: `스태틱은 객체를 생성하지 않고도 클래스 자체에서 바로 접근할 수 있습니다<br>
스태틱으로 선언된 변수나 메소드는 메모리에 로드될 때 한번만 초기화 됩니다<br>
예를들어 유틸리티 클래스에서 스태틱메서드를 활용해 객체 생성 없이<br>
공통적인 기능을 사용할 수 있도록 하고 인스턴스 변수는 각 객체가 따로<br>
가지도록 해서 메모리 절약과 간편한 접근을 유도할 수 있습니다`
  },
  {
    question: "26. 자바스크립트에서 호이스팅(Hoisting)이란?",
    answer: `호이스팅은 변수나 함수 선언이 실제 코드보다 먼저 상단으로 끌어올려지는<br>
자바스크립트의 동작 방식입니다<br>
그래서 코드에서 선언보다 먼저 변수를 사용하는 코드가 가능해지기도 하는데<br>
이 때 중요한 건 초기화 여부입니다<br>
var는 호이스팅이 되면서 undefined로 초기화 되기 때문에 사용은 가능하지만<br>
원치 않는 현상이 발생 할 수 있고<br>
let과 const는 초기화 되기 전까지는 접근 할 수 없기 때문에<br>
선언 전에 사용하면 에러가 발생합니다`
  },
  {
    question: "27. 콜백 지옥(Callback Hell)이란 무엇이고 어떻게 해결하나요?",
    answer: `자바스크립트에서 비동기 처리가 많이 쌓일수록<br>
콜백 함수가 중첩되기 때문에 코드가 복잡하고 읽기 어려워지는 문제입니다<br>
예를들어 여러 비동기 작업을 순차적으로 처리해야 할 때<br>
콜백 함수가 중첩되면 가독성이 떨어지면서 유지보수가 어려워집니다<br>
해결하려면 async/await를 사용해서 비동기 코드를 동기 코드처럼 작성할 수 있습니다`
  },
  {
    question: "28. CORS 오류가 발생한 적 있나요? 어떻게 해결했나요?",
    answer: `CORS 오류는 프론트와 백엔드가 서로 다른 도메인에서 실행 될 때 발생하는 오류로<br>
다른 도메인에서 자원 요청 시 발생하는 보안 정책 문제 입니다<br>
직접 경험한 적은 없지만<br>
이 문제를 해결하려면 서버에서 Access-Control-Allow-Origin 헤더를 설정해주거나<br>
Spring에서는 @CrossOrigin 어노테이션을 사용해서 허용할 도메인을 명시해줘야 하는걸로 알고있습니다`
  },
  {
    question: "29. RESTful URL 설계할 때 지켜야 할 원칙은?",
    answer: `레스트풀 설계시에는 자원을 명확하게 표현하고 계층 구조를 유지해야 합니다<br>
http메서드 (get post put delete)로 동작을 구분하는 것입니다<br>
자원은 users 처럼 url에서 명확히 알 수 있도록 명사로 표현하고<br>
http 메서드는 동사로써<br>
get 조회 post 생성이나 등록, put은 수정, delete는 삭제를 가르킵니다`
  },
  {
    question: "30. HTTP 메서드(GET, POST, PUT, DELETE)의 차이는?",
    answer: `http 메서드는 자원에 대한 작업을 정의하는데 사용하고<br>
GET은 서버에서 데이터를 가져올 때 사용하는 자원 조회<br>
POST는 서버에 새로운 데이터를 전송하고 생성하는데 사용하는 자원 생성<br>
PUT은 이미 존재하는 자원을 덮어 쓸 때 사용하는 자원 수정<br>
DELETE는 서버에서 특정 자원을 삭제할때 사용하는 자원 삭제를 뜻합니다`
  },
  {
    question: "31. Spring에서 @RequestBody와 @ResponseBody의 역할은?",
    answer: `먼저 리퀘스트바디는 HTTP 요청 본문에 담긴 데이터를 JAVA 객체로 변환하는 역할을 합니다<br>
클라이언트에서 JSON 형식으로 보낸 데이터를 자바 객체로 맵핑해 줍니다<br><br>
리스폰스바디는 JAVA 객체를 HTTP 응답 본문에 담아 클라이언트로 전송하는 역할입니다<br>
스프링은 반환된 자바 객체를 JSON 형식으로 변환해서 클라이언트에 응답합니다`
  },
  {
    question: "32. Session과 Cookie의 차이점은?",
    answer: `쿠키는 클라이언트 로컬에 저장되는 데이터이며 하나에 4KB 까지 저장 가능합니다.<br>
설정된 만료기간 동안 유지됩니다.<br><br>
세션은 서버에서 데이터를 관리합니다.<br>
그렇기 때문에 쿠키보다 보안에 좋긴 하지만<br>
사용자가 많아질수록 서버에 부담이 가서 성능 저하의 원인이 될 수 있습니다.<br>
브라우저가 닫힐때 까지 유지됩니다.`
  },
  {
    question: "33. JWT란 무엇이며, 로그인에 어떻게 활용되나요?",
    answer: `JWT는 사용자 인증과 정보를 안전하게 전송하기 위한 토큰입니다<br>
장접은 서버에서 세션 정보를 저장하지 않고도 사용자 인증을 할 수 있는 점이고<br>
정보가 답겨있기 때문에 매번 데이터베이스에 접근할 필요가 없어 효율적입니다`
  },
  {
    question: "34. Git에서 pull과 fetch의 차이점은?",
    answer: `fetch는 원격 저장소의 최신 커밋이나 브렌치 정보를 로컬로 가져오기만 하는 명령어이고<br>
pull은 fetch와 merge가 결합된 형태로<br>
원격저장소의 변경사항을 자동으로 로컬 브랜치에 병합 합니다`
  },
  {
    question: "35. merge 충돌이 발생했을 때 어떻게 해결하나요?",
    answer: `충돌 파일을 먼저 확인하고 git에서 표시해주는 충돌 부분을 수정합니다<br>
수정이 끝난 후 다시 병합 한 뒤 수정간 틀어진 로직은 없는지 테스트까지 진행합니다`
  },
    {
    question: "36. JavaScript에서 클로저(Closure)란 무엇인가요?",
    answer: `클로저는 함수가 선언될 당시 외부 변수를 기억하고<br>
실행된 이후에도 그 외부 변수에 접근할 수 있는 기능입니다<br>
자바스크립트는 함수를 값처럼 저장하고 반환할 수 있기 때문에<br>
내부 함수가 외부 함수의변수에 계속 접근할 수 있는 구조가 됩니다`
  },
  {
    question: "37. 타임리프(thymeleaf)의 th:if와 th:each의 기능은?",
    answer: `th:if와 th:each는 타임리프에서 조건문과 반복문을 처리하는데 쓰는 속성입니다<br>
if는 조건이 참일 때 html 태그를 랜더링 거짓일 땐 랜더링 되지 않습니다,<br>
each는 반복문 리스트나 배열 등의 컬렉션을 순회하면서 각 항목에 대해 반복적으로 랜더링 할 때 사용합니다`
  },
  {
    question: "38. 서버가 500 오류를 반환했다면 어떤 점을 확인하겠습니까?",
    answer: `500 오류는 서버 내부에서 예외가 발생했을 때 나오는 상태 코드이기 때문에,<br>
우선적으로 서버 로그를 확인해서 어떤 예외가 발생했는지 확인합니다<br>
로그를 보면 NullPointerException, SQL 오류, 타입 불일치 같은 에러 원인을 추적할 수 있고<br>
그 다음은 컨트롤러, 서비스, DB 쿼리 등 요청이 흐르는 전체 로직에서 문제가 없는지 확인합니다`
  },
  {
    question: "39. 비동기 통신 중 응답이 너무 느릴 경우 어떻게 조치할 수 있나요?",
    answer: `비동기 응답이 너무 느릴경우 사용자에겐 로딩표시를 하거나<br>
일정시간 이상 지연될 경우 타임아웃 설정과 에러메세지를 통해 사용자에게 안내합니다<br><br>
기술적인 측면으로는 API 응답 속도 분석을 먼저 하고<br>
백엔드에서 쿼리성능, 네트워크 지연, 서버 처리량 등을 로그로 확인해서 원인을 찾아야 합니다`
  },
  {
    question: "40. 프로젝트에서 경험한 가장 기억에 남는 버그는? 어떻게 해결했나요?",
    answer: `가장 기억에 남는 버그는 OpenAI API와 연결한 챗봇 응답이<br>
HTML에서는 이상하게 출력되던 문제였습니다 챗봇의 답변 데이터를<br>
실제 화면에서 출바꿈 없이 정리되지 않은 응답을 받아왔습니다<br><br>
처음에는 원인을 몰랐지만 JOSN 응답에 줄바꿈 문자가 있는것을 확인하고<br>
html 에서는 \\n이 아닌 br태그로 줄바꿈을 한다는 것을 깨달았습니다<br>
이를 해결하기 위해 응답 문자열의 \\n을 br태그로 바꾸는 전처리 로직을 추가했고<br>
곧바로 원하던 응답형태를 html에서 확인할 수 있었습니다<br><br>
이 과정을 통해 나중에 현업에서 같은 현상이 닥쳤을 것을 상상해 보았는데<br>
풀스택으로 개발하는 학원 프로젝트가 아닌 역할이 분리되어있는 현업에서 커뮤니케이션의 중요성을<br>
간접적으로나마 깊게 느꼈고 기술적으로는 API 연결만 되었다고 끝이 아니고<br>
프론트와의 상호작용을 위해 데이터를 가공하는 것도 중요하다고 느꼈습니다`
  }
];

let usedIndexes = [];
const questionEl = document.getElementById("question");
const answerEl = document.getElementById("answer");
const showAnswerBtn = document.getElementById("showAnswerBtn");
const nextBtn = document.getElementById("nextBtn");
const progressEl = document.getElementById("progress");

function pickRandomIndex() {
  if (usedIndexes.length === qaData.length) return null;

  let index;
  do {
    index = Math.floor(Math.random() * qaData.length);
  } while (usedIndexes.includes(index));

  usedIndexes.push(index);
  return index;
}

function loadQuestion() {
  const index = pickRandomIndex();
  if (index === null) {
    questionEl.textContent = "모든 질문을 다 보셨습니다!";
    answerEl.style.display = "none";
    showAnswerBtn.disabled = true;
    nextBtn.disabled = true;
    return;
  }

  const qa = qaData[index];
  questionEl.textContent = qa.question;
  answerEl.innerHTML = qa.answer;
  answerEl.style.display = "none";
  showAnswerBtn.disabled = false;
  progressEl.textContent = `현재 질문 ${usedIndexes.length} / 총 질문 ${qaData.length}`;
}

showAnswerBtn.onclick = () => {
  answerEl.style.display = "block";
};

nextBtn.onclick = () => {
  loadQuestion();
};

// 첫 질문 로딩
loadQuestion();